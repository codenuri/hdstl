// 6_선형컨테이너 - 112 page
// 




// 선형 컨테이너(sequence)
// => 모든 요소가 삽입된 순서대로 한줄로 놓여 있는것

// C++98 에서 3개
#include <vector>  // 연속된 메모리, 임의접근 반복자 ( + 연산 가능)
					// 요소 순회는 빠르다. 삽입삭제는 느리다.
					// 캐쉬 적중률이 높다.

#include <deque>   // 연속된 메모리와 유사, 임의접근 반복자 (+ 연산 가능)

#include <list>    // 떨어진 메모리, 양방향 반복자 (+ 연산 안됨. ++, --만 가능)
					// 요소 순회는 느리다. 삽입삭제는 빠르다.


// C++11 추가된 2개
#include <forward_list> // 싱글 링크드 리스트,  전진형 반복자
#include <array>		// 임의접근 반복자

#include "show.h"

int main()
{
	// 핵심 1. 선형 컨테이너 는 사용법의 거의 동일 합니다.
	//      => 그래서, 컨테이너 이름만 변경해서 
	//         성능을 측정해 볼수 있습니다.
//	std::list<int> c = { 1,2,3 };
	std::vector<int> c = { 1,2,3 };

	c.push_back(5);
	c.pop_back();


	// 핵심 2. 멤버 함수의 차이가 있다면 의도적인 설계 입니다.
	// => vector 는 앞쪽으로 삽입/삭제 안됩니다.
	// => 연속된 메모리의 앞쪽에 넣는 것은 오버헤드가 너무 큽니다.
	//    사용하지 말라는 의도 입니다.
	// => 전방 삽입이 필요 하면 list 나 deque 를 사용하세요
	c.push_front(5); // vector 라면 에러.


	// 핵심 3. [] 연산은 vector 와 deque 만 됩니다. list 안됩니다.
	c[0] = 10; // list 라면 에러!

	// 핵심 4. 일반적인 컨테이너 선택 규칙

	// [] 연산이 필요하고, 전방 삽입/삭제는 필요 없다. : ?  
	// [] 연산이 필요하고, 전방 삽입/삭제는 필요 하다. : ? 
	// [] 연산이 필요없고, 삽입/삭제를 많이 사용 한다. : ?
}
